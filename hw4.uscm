(use tree-manual.uscm)

;problem 1

(define-struct tree (value left right))

(define (path n t)
  (define (helper node)
    (cond
      ((null? node) #f)                   ; If the tree is empty, return #f.
      ((= n (tree-value node)) '())       ; If the current node contains the target integer, return an empty list.
      ((< n (tree-value node))            ; If the target is smaller, go left.
       (cons 'left (helper (tree-left node))))
      ((> n (tree-value node))            ; If the target is larger, go right.
       (cons 'right (helper (tree-right node))))))

  (let ((result (helper t)))
    (if result
        result
        #f)))


;Problem 2

(define tree (value left right))

(define (inorder t)
  (cond
    ((null? t) '())                      ; If the tree is empty, return an empty list.
 (else
     (append (inorder (tree-left t))     ; Inorder: Left, Root, Right
             (list (tree-value t))
             (inorder (tree-right t))))))

(define (postorder t)
  (cond
    ((null? t) '())                      ; If the tree is empty, return an empty list.
    (else
     (append (postorder (tree-left t))   ; Postorder: Left, Right, Root
             (postorder (tree-right t))
             (list (tree-value t))))))

; Problem 3
(define (explode-digits n)
 (if (< n 10)                            ; If the integer added is less than 10, add the integer to a list and return it.
  (cons n lst)
   (lst))
    (cons (explode-digits (/ n 10)) (lst (remainder n 10))))   ; If n is > 10, recursively call explode-digit and add the remainder of / n 10 to the list.

(define legnth (xs)
 (if (null? xs)
     0
     (+ 1 (length (cdr xs)))))

(set total-implode 0)
(define (implode-digits lst)
 (if (null? lst)
  total-implode				;Return 0 if list is empty
   (* 10 total-implode)			;Multiply previous total by 10 to incriment digit of last value
   (+ (car lst) (total-implode)))       ;Add the car of the list to the total
      (implode-digits (cdr lst))) 	;Recursively call the function with the cdr to increment
				

